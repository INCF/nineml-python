#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function
import nineml
from nineml.abstraction_layer.testing_utils import RecordValue, TestableComponent
from nineml.abstraction_layer import ComponentClass
from nineml.abstraction_layer.testing_utils import std_pynn_simulation
import os, sys, math
import numpy.random
from time import localtime, strftime, time
import expression_parser
import units_parser
from daetools.pyDAE import *

class identifierValue(object):
    """
    Internal class to wrap identifiers' values (can be numerical values or callable objects).
    """
    def __init__(self, value):
        self.value = value
        
    def __float__(self):
        """
        Achtung!! This makes identifierValue objects behave like numbers.
        """
        if isinstance(self.value, (long, int, float)):
            return float(self.value)
        
        else: # Is callable
            return float(self.value())
    
    def __str__(self):
        return '{0}'.format(self.__float__())
    
    def __repr__(self):
        return 'identifierValue({0})'.format(self.value)
    
def addIdentifiers(model, parent, dictIdentifiers):
    """
    Adds all identifiers (parameters, variables, inlet analogue ports) to the dictionary dictIdentifiers.
    This function is used to parse mathematical equations and conditional expressions and create
    daetools equation residual objects.
    Dictionary keys are relative canonical names (relative to the 'parent' model). For instance, if
    the canonical name of the 'model' is 'model1.model2.param1' and the canonical name of the 'parent'
    is 'model1' then the relative name is 'model2.param1' (the equations can access that parameters
    by using the identifier 'model2.param1').
    Dictionary values are daetools 'adouble' objects obtained by calling the function call operator
    of parameters (daeParameter class) and variables (daeVariable class). adouble class defines all standard 
    mathematical and logical operators and all standard mathematical functions (sqrt, exp, log, sin, cos, ...)
    so that the AST generated from the NineML expressions can be evaluated and equation residuals and
    logical expressions be constructed.
    
    :param model: nineml_daetools_bridge object
    :param parent: daeModel-derived object
    :param dictIdentifiers: python dictionary 'relative name' : adouble object
        
    :rtype: python dictionary (modified dictIdentifiers argument)
    :raises: RuntimeError
    """
    if not model:
        return dictIdentifiers
    
    for o in model.Parameters:
        relName = daeGetRelativeName(parent, o)
        #print('CanonicalName: {0}, RelName: {1}'.format(o.CanonicalName, relName))
        dictIdentifiers[relName] = o()

    for o in model.Variables:
        relName = daeGetRelativeName(parent, o)
        #print('CanonicalName: {0}, RelName: {1}'.format(o.CanonicalName, relName))
        dictIdentifiers[relName] = o()

    # Inlet analog ports do not have corresponding variable in the model (state or alias)
    # Outlet ports do have
    # Reduce ports have one that is generated by ninemlReduceAnalogPort class
    for port in model.nineml_analog_ports:
        if port.Type == eInletPort:
            if len(port.Variables) != 1:
                raise RuntimeError('Number of variables has to be 1, in the port ' + port.CanonicalName)
            relName = daeGetRelativeName(parent, port)
            #print('CanonicalName: {0}, RelName: {1}'.format(port.CanonicalName, relName))
            dictIdentifiers[relName] = port.Variables[0]()

    for m in model.Models:
        dictIdentifiers = addIdentifiers(m, model, dictIdentifiers)

    return dictIdentifiers

def addIdentifiersValues(model, parent, dictIdentifiers):
    """
    Identical to the function *addIdentifiers* except that it adds *identifierValue* objects 
    (and not *adouble* objects) which implement __float__ function so that they can be evaluated. 
    This function is used during initialization step when parsing expressions used to set parameters 
    values and initial conditions (to evaluate a value of an expression). It adds a callable object for 
    parameters'/variables' because values ain't initialized yet at this point.
    
    **Achtung!!** Some values might not be evaluated yet. Perhaps the values with simple numbers should 
    be set first and then expressions that depend on them evaluated.
    
    :param model: nineml_daetools_bridge object
    :param parent: daeModel-derived object
    :param dictIdentifiers: python dictionary 'relative name' : identifierValue object
        
    :rtype: python dictionary (modified dictIdentifiers argument)
    :raises: RuntimeError
    """
    if not model:
        return dictIdentifiers
    
    for o in model.Parameters:
        relName = daeGetRelativeName(parent, o)
        #print('CanonicalName: {0}, RelName: {1}'.format(o.CanonicalName, relName))
        dictIdentifiers[relName] = identifierValue(o.GetValue)

    for o in model.Variables:
        relName = daeGetRelativeName(parent, o)
        #print('CanonicalName: {0}, RelName: {1}'.format(o.CanonicalName, relName))
        dictIdentifiers[relName] = identifierValue(o.GetValue)

    # Inlet analog ports do not have corresponding variable in the model (state or alias)
    # Outlet ports do have
    # Reduce ports have one that is generated by ninemlReduceAnalogPort class
    if hasattr(model, 'nineml_analog_ports'):
        for port in model.nineml_analog_ports:
            if port.Type == eInletPort:
                if len(port.Variables) != 1:
                    raise RuntimeError('Number of variables has to be 1, in the port ' + port.CanonicalName)
                relName = daeGetRelativeName(parent, port)
                #print('CanonicalName: {0}, RelName: {1}'.format(port.CanonicalName, relName))
                dictIdentifiers[relName] = identifierValue(port.Variables[0].GetValue)

    for m in model.Models:
        dictIdentifiers = addIdentifiersValues(m, model, dictIdentifiers)

    return dictIdentifiers
    
_global_rng_ = numpy.random.RandomState()

def random_uniform(lowerBound = 0.0, upperBound = 1.0):
    res = _global_rng_.uniform(lowerBound, upperBound, 1)
    return float(res[0])

def random_normal(centre = 0.0, width = 1.0):
    res = _global_rng_.normal(centre, width)
    return float(res)

def random_binomial(n, p):
    res = _global_rng_.binomial(n, p)
    return float(res)

def random_poisson(lam = 1.0):
    res = _global_rng_.poisson(lam)
    return float(res)

def random_exponential(beta = 1.0):
    res = _global_rng_.exponential(beta)
    return float(res)

def createExpressionParser():
    return expression_parser.ExpressionParser()

def getEquationsExpressionParserIdentifiers(model):
    dictIdentifiers = {}

    dictIdentifiers['pi'] = Constant(math.pi)
    dictIdentifiers['e']  = Constant(math.e)
    dictIdentifiers['t']  = Time()
    if model:
        dictIdentifiers = addIdentifiers(model, model, dictIdentifiers)
    
    return dictIdentifiers

def getEquationsExpressionParserFunctions():
    dictFunctions   = {}

    # Standard math. functions (single argument)
    dictFunctions['__create_constant__'] = Constant
    dictFunctions['sin']   = Sin
    dictFunctions['cos']   = Cos
    dictFunctions['tan']   = Tan
    dictFunctions['asin']  = ASin
    dictFunctions['acos']  = ACos
    dictFunctions['atan']  = ATan
    dictFunctions['sinh']  = Sinh
    dictFunctions['cosh']  = Cosh
    dictFunctions['tanh']  = Tanh
    dictFunctions['asinh'] = ASinh
    dictFunctions['acosh'] = ACosh
    dictFunctions['atanh'] = ATanh
    dictFunctions['log10'] = Log10
    dictFunctions['log']   = Log
    dictFunctions['sqrt']  = Sqrt
    dictFunctions['exp']   = Exp
    dictFunctions['floor'] = Floor
    dictFunctions['ceil']  = Ceil
    dictFunctions['fabs']  = Abs

    # Non-standard functions (multiple arguments)
    dictFunctions['pow']   = Pow

    # Random distributions, non-standard functions
    # Achtung!! Should be used only in StateAssignments statements
    dictFunctions['random.uniform']     = random_uniform
    dictFunctions['random.normal']      = random_normal
    dictFunctions['random.binomial']    = random_binomial
    dictFunctions['random.poisson']     = random_poisson
    dictFunctions['random.exponential'] = random_exponential

    #print(dictIdentifiers)
    #print(dictFunctions)
    return dictFunctions

def getEquationsExpressionParser(model):
    """
    Returns the ExpressionParser object needed to parse NineML mathematical and logical expressions.
    
    :param model: daeModel-derived object
        
    :rtype: ExpressionParser object
    :raises:
    """
    dictIdentifiers = getEquationsExpressionParserIdentifiers(model)
    dictFunctions   = getEquationsExpressionParserFunctions()
    parser = expression_parser.ExpressionParser(dictIdentifiers, dictFunctions)
    return parser

def getParametersValuesInitialConditionsExpressionParserIdentifiers(model):
    dictIdentifiers = {}
    dictIdentifiers['pi'] = math.pi
    dictIdentifiers['e']  = math.e
    if model:
        dictIdentifiers = addIdentifiers(model, model, dictIdentifiers)
    return dictIdentifiers

def getParametersValuesInitialConditionsExpressionParserFunctions():
    dictFunctions   = {}
    
    # Standard math. functions (single argument)
    dictFunctions['__create_constant__'] = float
    dictFunctions['sin']   = math.sin
    dictFunctions['cos']   = math.cos
    dictFunctions['tan']   = math.tan
    dictFunctions['asin']  = math.asin
    dictFunctions['acos']  = math.acos
    dictFunctions['atan']  = math.atan
    dictFunctions['sinh']  = math.sinh
    dictFunctions['cosh']  = math.cosh
    dictFunctions['tanh']  = math.tanh
    dictFunctions['asinh'] = math.asinh
    dictFunctions['acosh'] = math.acosh
    dictFunctions['atanh'] = math.atanh
    dictFunctions['log10'] = math.log10
    dictFunctions['log']   = math.log
    dictFunctions['sqrt']  = math.sqrt
    dictFunctions['exp']   = math.exp
    dictFunctions['floor'] = math.floor
    dictFunctions['ceil']  = math.ceil
    dictFunctions['fabs']  = math.fabs
    # Non-standard functions (multiple arguments)
    
    dictFunctions['pow']   = math.pow
    return dictFunctions
    
def getParametersValuesInitialConditionsExpressionParser(model):
    """
    Returns the ExpressionParser object needed to parse the expressions for parameters' values 
    and initial conditions:    
    
    :param model: daeModel-derived object
        
    :rtype: ExpressionParser object
    :raises:
    """
    dictIdentifiers = getParametersValuesInitialConditionsExpressionParserIdentifiers(model)
    dictFunctions   = getParametersValuesInitialConditionsExpressionParserFunctions()
    parser = expression_parser.ExpressionParser(dictIdentifiers, dictFunctions)
    return parser
    
def getAnalogPortsExpressionParser():
    """
    Returns the ExpressionParser object needed to parse inputs for the analogue ports:
    
    :param model: daeModel-derived object
        
    :rtype: ExpressionParser object
    :raises:
    """
    dictIdentifiers = {}
    dictFunctions   = {}

    dictIdentifiers['pi'] = math.pi
    dictIdentifiers['e']  = math.e

    # Standard math. functions (single argument)
    dictFunctions['sin']   = math.sin
    dictFunctions['cos']   = math.cos
    dictFunctions['tan']   = math.tan
    dictFunctions['asin']  = math.asin
    dictFunctions['acos']  = math.acos
    dictFunctions['atan']  = math.atan
    dictFunctions['sinh']  = math.sinh
    dictFunctions['cosh']  = math.cosh
    dictFunctions['tanh']  = math.tanh
    dictFunctions['asinh'] = math.asinh
    dictFunctions['acosh'] = math.acosh
    dictFunctions['atanh'] = math.atanh
    dictFunctions['log10'] = math.log10
    dictFunctions['log']   = math.log
    dictFunctions['sqrt']  = math.sqrt
    dictFunctions['exp']   = math.exp
    dictFunctions['floor'] = math.floor
    dictFunctions['ceil']  = math.ceil
    dictFunctions['fabs']  = math.fabs

    # Non-standard functions (multiple arguments)
    dictFunctions['pow']   = math.pow

    parser = expression_parser.ExpressionParser(dictIdentifiers, dictFunctions)
    return parser

def printComponent(c, name, indent_string = '  ', level = 0):
    """
    Mickey Mice function to print AL component to stdout.
    
    :param c: AL Component object
    :param name: string
    :param indent_string: string
    :param level: integer
        
    :rtype: None
    :raises:
    """
    indent = level*indent_string
    print(indent + '+ COMPONENT: [{0}], class: [{1}]'.format(name, c.__class__.__name__))

    indent = indent + '  '

    print(indent + 'parameters:')
    for o in c.parameters:
        print(indent + indent_string, o)

    print(indent + 'state_variables:')
    for o in c.state_variables:
        print(indent + indent_string, o)

    print(indent + 'aliases:')
    for o in c.aliases:
        print(indent + indent_string, o)

    print(indent + 'regimes:')
    for o in c.regimes:
        print(indent + indent_string, o)

        print(indent + indent_string + 'transitions:')
        for t in o.on_conditions:
            print(indent + 2*indent_string + 'source_regime.name: ' + t.source_regime.name)
            print(indent + 2*indent_string + 'target_regime.name: ' + t.target_regime.name)
            print(indent + 2*indent_string + 'trigger: ' + t.trigger.rhs)
            print(indent + 2*indent_string + 'state_assignments:')
            for sa in t.state_assignments:
                print(indent + 3*indent_string + sa.lhs + ' = ' + sa.rhs)
            print(indent + 2*indent_string + 'event_outputs:')
            for eo in t.event_outputs:
                print(indent + 3*indent_string + str(eo))
                
        for t in o.on_events:
            print(indent + 2*indent_string + 'src_port_name: ' + t.src_port_name)
            print(indent + 2*indent_string + 'source_regime_name: ' + t.source_regime.name)
            print(indent + 2*indent_string + 'target_regime_name: ' + t.target_regime.name)
            print(indent + 2*indent_string + 'state_assignments:')
            for sa in t.state_assignments:
                print(indent + 3*indent_string + sa.lhs + ' = ' + sa.rhs)
            print(indent + 2*indent_string + 'event_outputs:')
            for eo in t.event_outputs:
                print(indent + 3*indent_string + str(eo))


    print(indent + 'analog_ports:')
    for o in c.analog_ports:
        print(indent + indent_string, o)

    print(indent + 'event_ports:')
    for o in c.event_ports:
        print(indent + indent_string, o)

    print(indent + 'portconnections:')
    for o in c.portconnections:
        print(indent + indent_string + ' {0} -> {1}'.format(o[0].getstr('.'), o[1].getstr('.')))

    print(indent + 'subnodes:')
    for name, subc in list(c.subnodes.items()):
        printComponent(subc, name, indent_string, level+1)

def findObjectInModel(model, name, **kwargs):
    """
    Looks for and returns the object with the 'name' in the daeModel-derived object 'model'.
    
    :param model: daeModel-derived object
    :param name: string
    :param kwargs: list of boolean flags determining the type of objects to look for
        
    :rtype: python object (depends on kwargs argument)
    :raises: RuntimeError
    """
    look_for_domains     = kwargs.get('look_for_domains',     False)
    look_for_parameters  = kwargs.get('look_for_parameters',  False)
    look_for_variables   = kwargs.get('look_for_variables',   False)
    look_for_ports       = kwargs.get('look_for_ports',       False)
    look_for_reduceports = kwargs.get('look_for_reduceports', False)
    look_for_eventports  = kwargs.get('look_for_eventports',  False)
    look_for_stns        = kwargs.get('look_for_stns',        False)
    look_for_models      = kwargs.get('look_for_models',      False)

    objects = []
    look_for_all = True

    # If any of those is set then set look_for_all to False
    if look_for_domains or look_for_parameters or look_for_variables or look_for_ports or look_for_reduceports or look_for_eventports or look_for_models or look_for_stns:
        look_for_all = False

    if look_for_all:
        objects = model.Domains + model.Parameters + model.Variables + model.Ports + model.EventPorts + model.STNs + model.Models
    else:
        if look_for_domains:
            objects = objects + model.Domains
        if look_for_parameters:
            objects = objects + model.Parameters
        if look_for_variables:
            objects = objects + model.Variables
        if look_for_ports:
            objects = objects + model.Ports
        if look_for_reduceports:
            objects = objects + model.nineml_reduce_ports
        if look_for_eventports:
            objects = objects + model.EventPorts
        if look_for_models:
            objects = objects + model.Models
        if look_for_stns:
            objects = objects + model.STNs

    mapObjects = {}
    for o in objects:
        mapObjects[o.Name] = o
    
    if name in mapObjects:
        return mapObjects[name]
    return None

def getObjectFromNamespaceAddress(rootModel, address, **kwargs):
    """
    Recursively looks for and returns the object with the name 'address' in the toplevel daeModel-derived object 'rootModel'.
    
    :param rootModel: daeModel-derived object
    :param address: AL NamespaceAddress object
    :param kwargs: list of boolean flags determining the type of objects to look for
        
    :rtype: python object (depends on kwargs argument)
    :raises: RuntimeError
    """
    canonicalName = '.'.join(address.loctuple)
    return getObjectFromCanonicalName(rootModel, canonicalName, **kwargs)

def getObjectFromCanonicalName(rootModel, canonicalName, **kwargs):
    """
    Recursively looks for and returns the object with the name 'address' in the toplevel daeModel-derived object 'rootModel'.

    :param rootModel: daeModel-derived object
    :param canonicalName: a 'path' to the object ('model1.model2.object')
    :param kwargs: list of boolean flags determining the type of objects to look for
        
    :rtype: python object (depends on kwargs argument)
    :raises: RuntimeError
    """
    relativeName = daeGetRelativeName(rootModel.CanonicalName, canonicalName)
    #print('  relativeName = {0} for root = {1} and canonicalName = {2}'.format(relativeName, rootModel.CanonicalName, canonicalName))
    listCanonicalName = relativeName.split('.')
    objectName = listCanonicalName[-1]
    objectPath = listCanonicalName[:-1]

    root = rootModel
    if len(objectPath) > 0:
        for name in objectPath:
            root = findObjectInModel(root, name, look_for_models = True)
            if root == None:
                raise RuntimeError('Could not locate object {0} in {1}'.format(name, ".".join(objectPath)))

    # Now we have the model where port should be located (root)
    # Search for the 'name' in the 'root' model (in the types of objects given in **kwargs)
    return findObjectInModel(root, objectName, **kwargs)

def fixObjectName(name):
    """
    Replaces spaces in the 'name' string with underscores and returns the modified string.
    
    :param name: string
        
    :rtype: string
    :raises:
    """
    new_name = name.replace(' ', '_')
    return new_name

dae_nineml_t = daeVariableType("dae_nineml_t", unit(), -1.0e+20, 1.0e+20, 0.0, 1e-12)

class ninemlAnalogPort(daePort):
    """
    Represents NineML analogue ports with a single variable (referred to with the 'value' daeVariable). 
    """
    def __init__(self, Name, PortType, Model, Description = ''):
        """
        :param Name: string
        :param PortType: daetools port type (eInlet, eOutlet, eInletOutlet)
        :param Model: daeModel-derived object
        :param Description: string
            
        :raises: RuntimeError
        """
        daePort.__init__(self, Name, PortType, Model, Description)

        # NineML ports always contain only one variable, and that variable is referred to by the port name
        # Here we name this variable 'value'
        self.value = daeVariable("value", dae_nineml_t, self, "")

class ninemlReduceAnalogPort(object):
    """
    A workaround around NineML reduce analogue ports (there are no reduce ports in daetools; it's done 
    by using multiple ports and creating equations that do some operations on their variables). 
    Whenever a connection to a reduce ports is requested a new ninemlAnalogPort object is created and
    connected to the requested source port. Once all connections are made a single equation that sums up
    'value' variables from all generated ports is created and added to the model.
    """
    def __init__(self, name, model):
        """
        :param name: string
        :param model: daeModel-derived object
            
        :raises: RuntimeError
        """
        self.Ports        = []
        self.Name         = name
        self.Model        = model
        self.portVariable = daeVariable(self.Name, dae_nineml_t, self.Model, "")

    def addPort(self):
        """
        Creates a new ninemlAnalogPort object (when a connection to a reduce ports is requested).
        
        :rtype: ninemlAnalogPort object
        :raises: RuntimeError
        """
        name = '{0}_{1}'.format(self.Name, len(self.Ports))
        port = ninemlAnalogPort(name, eInletPort, self.Model, '')
        self.Ports.append(port)
        return port

    def generateEquation(self):
        """
        Creates an equation that sums up 'value' variables from all generated ports.
        The equation is added to the parent model specified in the __init__ function.
        
        :rtype: ninemlAnalogPort object
        :raises: RuntimeError
        """
        eq = self.Model.CreateEquation(self.Name, "")
        varSum = adouble()
        for p in self.Ports:
            varSum = varSum + p.value()
        eq.Residual = self.portVariable() - varSum

class daetoolsVariableParameterDictionaryWrapper(object):
    """
    Dictionary-like class to wrap multidimensional parameters, variables, etc
    A workaround to save a lot of time that would be spent on creating dictionaries
    for each neurone/connection.
    """
    def __init__(self, dictIDs, current_index = None):
        """
        :param dictIDs: python dictionary 'name' : daeVariable/daeParameter; 
                        they should be distributed on a single domain.
        :param current_index: daeDEDI object
        """
        self.dictIDs       = dictIDs
        self.current_index = current_index
        
    def __contains__(self, key):
        return key in self.dictIDs

    def has_key(self, key):
        return key in self.dictIDs

    def __getitem__(self, key):
        """
        Gets the daeVariable object at the given *key* and calls *operator ()*
        with the index equal to the *current_index* argument.
        """
        obj = self.dictIDs[key]
        if isinstance(obj, adouble):
            return obj
        
        elif isinstance(obj, (daeParameter, daeVariable)):
            if self.current_index == None:
                if len(obj.Domains) > 0:
                    raise RuntimeError('')
                return obj()
            
            else:
                if len(obj.Domains) > 0:
                    return obj(self.current_index)
                else:
                    raise RuntimeError('')
        else:
            raise RuntimeError('')

__equation_parser__ = getEquationsExpressionParser(None)

class nineml_daetools_bridge(daeModel):
    """
    A wrapper around a single or hierarchical AL Component object.
    """
    
    # AL components always have a single STN with several regimes; this is a generic name for NineML STNs  
    ninemlSTNRegimesName = 'NineML_Regimes_STN'

    def __init__(self, Name, ninemlComponent, Parent = None, Description = ""):
        """
        Iterates over *Parameters*, *State variables*, *Aliases*, *Analogue ports*, *Event ports*, 
        *Sub-nodes* and *Port connections* and creates corresponding daetools objects.
        
        :param Name: string
        :param ninemlComponent: AL component object
        :param Parent: daeModel-derived object
        :param Description: string
            
        :raises: RuntimeError
        """
        #start = time()
        
        daeModel.__init__(self, Name, Parent, Description)
        
        #print('    daeModel.__init__({0}) = {1}'.format(Name, time() - start))

        start = time()

        self.ninemlComponent        = ninemlComponent
        self.nineml_parameters      = []
        self.nineml_state_variables = []
        self.nineml_aliases         = []
        self.nineml_analog_ports    = []
        self.nineml_reduce_ports    = []
        self.nineml_event_ports     = []
        self.ninemlSubComponents    = []

        # AL component may be None (useful in certain cases); therefore do not raise an exception
        if not self.ninemlComponent:
            return
        
        # 1) Create parameters
        for param in self.ninemlComponent.parameters:
            self.nineml_parameters.append( daeParameter(param.name, unit(), self, "") )

        # 2) Create state-variables (diff. variables)
        for var in self.ninemlComponent.state_variables:
            self.nineml_state_variables.append( daeVariable(var.name, dae_nineml_t, self, "") )

        # 3) Create alias variables (algebraic)
        for alias in self.ninemlComponent.aliases:
            self.nineml_aliases.append( daeVariable(alias.lhs, dae_nineml_t, self, "") )

        # 4) Create analog-ports and reduce-ports
        for analog_port in self.ninemlComponent.analog_ports:
            if analog_port.mode == 'send':
                self.nineml_analog_ports.append( ninemlAnalogPort(analog_port.name, eOutletPort, self, "") )
            elif analog_port.mode == 'recv':
                self.nineml_analog_ports.append( ninemlAnalogPort(analog_port.name, eInletPort, self, "") )
            elif analog_port.mode == 'reduce':
                self.nineml_reduce_ports.append( ninemlReduceAnalogPort(analog_port.name, self) )
            else:
                raise RuntimeError("")

        # 5) Create event-ports
        for event_port in self.ninemlComponent.event_ports:
            if event_port.mode == 'send':
                self.nineml_event_ports.append( daeEventPort(event_port.name, eOutletPort, self, "") )
            elif event_port.mode == 'recv':
                self.nineml_event_ports.append( daeEventPort(event_port.name, eInletPort, self, "") )
            else:
                raise RuntimeError("")

        # 6) Create sub-nodes
        for name, subcomponent in list(self.ninemlComponent.subnodes.items()):
            self.ninemlSubComponents.append( nineml_daetools_bridge(name, subcomponent, self, '') )

        # 7) Create port connections
        for port_connection in self.ninemlComponent.portconnections:
            #print 'try to connect {0} to {1}'.format(port_connection[0].getstr('.'), port_connection[1].getstr('.'))
            portFrom = getObjectFromNamespaceAddress(self, port_connection[0], look_for_ports = True, look_for_reduceports = True)
            portTo   = getObjectFromNamespaceAddress(self, port_connection[1], look_for_ports = True, look_for_reduceports = True)
            #print '  {0} -> {1}\n'.format(type(portFrom), type(portTo))
            connectPorts(portFrom, portTo, self)
        
        #print('    the rest = {0}'.format(time() - start))
            
    def DeclareEquations(self):
        """
        Iterates over *aliases*, *reduce analogue ports* and *regimes*, parses mathematical and logical expressions
        and generates daetools equation objects and state transition networks.
        
        :rtype: None
        :raises: RuntimeError
        """
        # Add identifiers for 
        __equation_parser__.dictIdentifiers = getEquationsExpressionParserIdentifiers(self)
        
        # 1) Create aliases (algebraic equations)
        aliases = list(self.ninemlComponent.aliases)
        if len(aliases) > 0:
            for i, alias in enumerate(aliases):
                eq = self.CreateEquation(alias.lhs, "")
                eq.Residual = self.nineml_aliases[i]() - __equation_parser__.parse_and_evaluate(alias.rhs)

        # 1a) Create equations for reduce ports (algebraic equations)
        for port in self.nineml_reduce_ports:
            port.generateEquation()

        # 2) Create regimes
        regimes         = list(self.ninemlComponent.regimes)
        state_variables = list(self.ninemlComponent.state_variables)
        if len(regimes) > 0:
            # 2a) Create STN for model
            self.STN(nineml_daetools_bridge.ninemlSTNRegimesName)

            for regime in regimes:
                # 2b) Create State for each regime
                self.STATE(regime.name)

                # 2c) Create equations for all state variables/time derivatives
                # Sometime a time_derivative equation is not given and in that case the derivative is equal to zero
                # We have to discover which variables do not have a corresponding ODE and
                # we do that by creating a map {'state_var' : 'RHS'} which initially has
                # set rhs to '0'. RHS will be set later while iterating through ODEs
                map_statevars_timederivs = {}
                for state_var in state_variables:
                    map_statevars_timederivs[state_var.name] = 0

                time_derivatives = list(regime.time_derivatives)
                for time_deriv in time_derivatives:
                    map_statevars_timederivs[time_deriv.dependent_variable] = time_deriv.rhs
                #print map_statevars_timederivs

                for var_name, rhs in list(map_statevars_timederivs.items()):
                    variable = self._findVariable(var_name)
                    if variable == None:
                        raise RuntimeError('Cannot find state variable {0}'.format(var_name))

                    # Create equation
                    eq = self.CreateEquation(var_name, "")

                    # If right-hand side expression is 0 do not parse it
                    if rhs == 0:
                        eq.Residual = variable.dt()
                    else:
                        eq.Residual = variable.dt() - __equation_parser__.parse_and_evaluate(rhs)

                # 2d) Create on_condition actions
                for on_condition in regime.on_conditions:
                    condition         = __equation_parser__.parse_and_evaluate(on_condition.trigger.rhs)
                    switchTo          = on_condition.target_regime.name
                    triggerEvents     = []
                    setVariableValues = []

                    for state_assignment in on_condition.state_assignments:
                        variable   = getObjectFromCanonicalName(self, state_assignment.lhs, look_for_variables = True)
                        if variable == None:
                            raise RuntimeError('Cannot find variable {0}'.format(state_assignment.lhs))
                        expression = __equation_parser__.parse_and_evaluate(state_assignment.rhs)
                        setVariableValues.append( (variable, expression) )

                    for event_output in on_condition.event_outputs:
                        event_port = getObjectFromCanonicalName(self, event_output.port_name, look_for_eventports = True)
                        if event_port == None:
                            raise RuntimeError('Cannot find event port {0}'.format(event_output.port_name))
                        triggerEvents.append( (event_port, Time()) )

                    # ACHTUNG!!!
                    # Check the order of switchTo, triggerEvents and setVariableValues arguments in daetools 1.2.0+!!!
                    self.ON_CONDITION(condition, switchTo          = switchTo,
                                                 setVariableValues = setVariableValues,
                                                 triggerEvents     = triggerEvents)

                # 2e) Create on_event actions
                for on_event in regime.on_events:
                    source_event_port = getObjectFromCanonicalName(self, on_event.src_port_name, look_for_eventports = True)
                    if source_event_port == None:
                        raise RuntimeError('Cannot find event port {0}'.format(on_event.src_port_name))
                    
                    switchToStates    = []
                    triggerEvents     = []
                    setVariableValues = []

                    for state_assignment in on_event.state_assignments:
                        variable   = getObjectFromCanonicalName(self, state_assignment.lhs, look_for_variables = True)
                        if variable == None:
                            raise RuntimeError('Cannot find variable {0}'.format(state_assignment.lhs))
                        expression = __equation_parser__.parse_and_evaluate(state_assignment.rhs)
                        setVariableValues.append( (variable, expression) )

                    for event_output in on_event.event_outputs:
                        event_port = getObjectFromCanonicalName(self, event_output.port_name, look_for_eventports = True)
                        if event_port == None:
                            raise RuntimeError('Cannot find event port {0}'.format(event_output.port_name))
                        triggerEvents.append( (event_port, Time()) )

                    # ACHTUNG!!!
                    # Check the order of switchTo, triggerEvents and setVariableValues arguments in daetools 1.2.0+!!!
                    self.ON_EVENT(source_event_port, switchToStates    = switchToStates,
                                                     setVariableValues = setVariableValues,
                                                     triggerEvents     = triggerEvents)
                                                 
            self.END_STN()

        # 3) Create equations for outlet analog-ports: port.value() - variable() = 0
        for analog_port in self.nineml_analog_ports:
            if analog_port.Type == eOutletPort:
                eq = self.CreateEquation(analog_port.Name + '_portequation', "")
                var_to = findObjectInModel(self, analog_port.Name, look_for_variables = True)
                if var_to == None:
                    raise RuntimeError('Cannot find variable/alias {0}'.format(analog_port.Name))
                eq.Residual = analog_port.value() - var_to()

    def _findVariable(self, name):
        for var in self.nineml_state_variables:
            if var.Name == name:
                return var
        return None

    def getSpikeInPort(self): 
        for event_port in self.nineml_event_ports:
            if event_port.Type == eInletPort:
                return event_port
                
        raise RuntimeError('{0} does not have any receive event ports'.format(self.CanonicalName))

    def getSpikeOutPort(self): 
        for event_port in self.nineml_event_ports:
            if event_port.Type == eOutletPort:
                return event_port
                
        raise RuntimeError('{0} does not have any send event ports'.format(self.CanonicalName))

def connectPorts(portInlet, portOutlet, parent_model):
    """
    Connects two analogue ports and stores the connection in the 'parent_model' object.
    
    :param portInlet: ninemlAnalogPort|ninemlReduceAnalogPort object
    :param portOutlet: ninemlAnalogPort|ninemlReduceAnalogPort object
    :param parent_model: daeModel-derived object
        
    :rtype: None
    :raises: RuntimeError
    """
    portFrom = None
    portTo   = None

    if isinstance(portInlet, ninemlAnalogPort):
        portFrom = portInlet
    elif isinstance(portInlet, ninemlReduceAnalogPort):
        portFrom = portInlet.addPort()
    else:
        raise RuntimeError('invalid portFrom')
        
    if isinstance(portOutlet, ninemlAnalogPort):
        portTo = portOutlet
    elif isinstance(portOutlet, ninemlReduceAnalogPort):
        portTo = portOutlet.addPort()
    else:
        raise RuntimeError('invalid portTo')

    parent_model.ConnectPorts(portFrom, portTo)

def connectEventPorts(portFrom, portTo, parent_model):
    """
    Connects two event ports and stores the connection in the 'parent_model' object.
    
    :param portFrom: daeEventPort object
    :param portTo: daeEventPort object
    :param parent_model: daeModel-derived object
        
    :rtype: None
    :raises: RuntimeError
    """
    if (portFrom.Type != eOutletPort) or (portTo.Type != eInletPort):
        raise RuntimeError('Cannot connect event ports: incompatible types')
    
    parent_model.ConnectEventPorts(portTo, portFrom)

def connectModelsViaEventPort(source, target, parent_model):
    """
    Connects the source and the target models via single event port and stores the connection in the 
    'parent_model' object. There must be a single outlet port in the source model and a single inlet 
    port in the target model. 
    
    :param source: nineml_daetools_bridge object (neurone)
    :param target: nineml_daetools_bridge object (target)
    :param parent_model: daeModel object (typically a network object)
        
    :rtype: None
    :raises: RuntimeError
    """
    source_port = source.getSpikeOutPort()
    target_port = target.getSpikeInPort()
    connectEventPorts(source_port, target_port, parent_model)

def connectModelsViaAnaloguePorts(source, target, parent_model):
    """
    Connects all analogue ports in the source model to all analogue ports in the target model 
    and stores the connections in the parent_model.
    The function iterates over the source ports and tries to find its match in the target ports.
    If a match is found it connects them. If a match is not found, or if an incompatible pair 
    of ports has been found it throws an exception.
    
    **ACHTUNG, ACHTUNG!!** It is assumed that sources do not have reduce ports [tamba/lamba?]
    
    :param source: nineml_daetools_bridge object (synapse)
    :param target: nineml_daetools_bridge object (neurone)
    :param parent_model: nineml_daetools_bridge object (typically a network object)
        
    :rtype: None
    :raises: RuntimeError
    """
    for source_port in source.nineml_analog_ports:
        matching_port_found = False
        
        # 1) Look in the list of analogue ports
        for target_port in target.nineml_analog_ports:
            if source_port.Name == target_port.Name:
                if (source_port.Type == eInletPort) and (target_port.Type == eOutletPort):
                    connectPorts(source_port, target_port, parent_model)
                    matching_port_found = True
                
                elif (source_port.Type == eOutletPort) and (target_port.Type == eInletPort):
                    connectPorts(source_port, target_port, parent_model)
                    matching_port_found = True
                
                else:
                    msg = 'Cannot connect a source to a neurone: source port [{0}] and neurone port [{1}] do not match'.format(source_port.Name, target_port.Name)
                    raise RuntimeError(msg)
        
        # 2) If not connected yet, look in the list of reduce ports
        if matching_port_found == False:
            for target_port in target.nineml_reduce_ports:
                if source_port.Name == target_port.Name:
                    # Achtung! Reduce ports are implicitly inlet
                    if (source_port.Type == eOutletPort):
                        connectPorts(source_port, target_port, parent_model)
                        matching_port_found = True
        
        # If not found - die miserably
        if matching_port_found == False:
            raise RuntimeError('Cannot connect a source to a neurone: cannot find a match for the source port [{0}]'.format(source_port.Name))

class daetools_spike_source(nineml_daetools_bridge):
    """
    Used to generate spikes according to the predefined sequence.
    The component has no parameters
    """
    def __init__(self, spiketimes, Name, Parent = None, Description = ""):
        nineml_daetools_bridge.__init__(self, Name, None, Parent, Description)

        # A dummy variable
        self.event = pyCore.daeVariable("event", time_t, self, "")
        
        # Add one 'send' event port
        self.spikeoutput = pyCore.daeEventPort("spikeoutput", eOutletPort, self, "Spike outlet event port")
        self.nineml_event_ports.append(self.spikeoutput)
        
        # A list of spike event times
        self.spiketimes = list(spiketimes)

    def DeclareEquations(self):
        self.stnSpikeSource = self.STN("SpikeSource")

        for i, t in enumerate(self.spiketimes):
            self.STATE('State_{0}'.format(i))
            eq = self.CreateEquation("event")
            eq.Residual = self.event() - t
            self.ON_CONDITION(Time() >= t,  switchTo      = 'State_{0}'.format(i+1),
                                            triggerEvents = [(self.spikeoutput, Time())])

        self.STATE('State_{0}'.format(len(self.spiketimes)))

        eq = self.CreateEquation("event")
        eq.Residual = self.event()

        self.END_STN()

def createPoissonSpikeTimes(rate, duration, t0, rng_poisson, lambda_, rng_uniform):
    n  = int(rng_poisson.poisson(lambda_, 1))
    spiketimes = sorted(rng_uniform.uniform(t0, t0+duration, n))
    #print(lam, n, spiketimes)
    return spiketimes
  
if __name__ == "__main__":
    al_component  = TestableComponent('hierachical_iaf_1coba')()
    if not al_component:
        raise RuntimeError('Cannot load NineML component')
    